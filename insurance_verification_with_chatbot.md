# Insurance Verification System with AI Chatbot Assistant

## 1 — Project Overview & Goals
Goal: Build a secure, scalable Insurance Verification system with a conversational AI chatbot assistant.  
The system will:  
- Verify insurance details via external provider APIs.  
- Cache results to reduce provider calls.  
- Store records for auditing.  
- Provide both a **web UI (React)** and a **chatbot assistant** to answer live queries (policy number, coverage, expiry).  

---

## 2 — High-level Architecture
```
Frontend (React Web App + Chatbot Widget)
   ↓
Chatbot Middleware (Rasa or LangChain + LLM)
   ↓
Backend API (FastAPI)
   ↓
In-Memory Database (Redis) + Cache Layer
   ↓
External Provider APIs
```

---

## 3 — Components & Responsibilities

### Frontend (React)
- **Insurance Verification UI:**  
  - Input forms, submit verification requests, show results/history.  
- **Chatbot Widget:**  
  - React chat UI component (`react-chat-widget` or custom).  
  - Conversational queries about policy info.  
  - Authenticated before allowing queries.  

### Backend (FastAPI)
- **Verification Service:** Handles structured verification requests.  
- **Policy Info Endpoint:** `/api/policy-info` for chatbot queries.  
- **In-Memory Storage:** Redis for fast results and data persistence.  
- **Data Persistence:** All records stored in memory with optional backup to disk.  
- **Auth & Security:** JWT or OAuth2.  
- **Observability:** Logging, metrics, tracing.  

### Chatbot Middleware
- **Option A: Rasa (open-source NLU)**  
- **Option B: LangChain + GPT-5** (natural conversation, easier to extend)  
- Responsibilities:  
  - Classify intent (`get_policy_number`, `check_coverage`, `check_expiry`).  
  - Extract entities (policy number, member ID, DOB).  
  - Forward structured request to backend API.  
  - Return normalized JSON response back to user.  

### In-Memory Database (Redis)
- **Data Structures:**  
  - `providers:*` — provider metadata (Hash).  
  - `verifications:*` — verification history (Hash with JSON).  
  - `audit_logs:*` — user queries/actions (List/Stream).  
  - `policies:*` — structured policy data (Hash).  
  - `cache:*` — provider response cache (String with TTL).  
- **Features:**
  - Fast in-memory operations.  
  - Optional persistence to disk (RDB/AOF).  
  - Built-in expiration and TTL support.  
  - Circuit-breaker + rate limiting via Redis modules.  

---

## 4 — Data Model (Redis In-Memory)

### policies:* (Redis Hash)
**Key Pattern:** `policies:{member_id_hash}`  
**Fields:**
- id (string)  
- member_id (hashed)  
- policy_number (string)  
- coverage_status (active|inactive|expired)  
- expiry_date (ISO string)  
- source (provider|cache)  
- verified_at (timestamp)  
- created_at, updated_at (timestamps)  

### verifications:* (Redis Hash)
**Key Pattern:** `verifications:{request_id}`  
**Fields:**
- id (string)  
- request_id (string)  
- provider_id (string)  
- member_key_hash (string)  
- normalized_request (JSON string)  
- provider_response (JSON string)  
- source (cache|provider)  
- verified_at (timestamp)  
- created_at, updated_at (timestamps)  

### audit_logs:* (Redis Stream)
**Key Pattern:** `audit_logs:{date}` (daily streams)  
**Fields:**
- user_id (string)  
- action (verify_request|chat_query)  
- details (JSON string)  
- timestamp (auto-generated by Redis Stream)  

### cache:* (Redis String with TTL)
**Key Pattern:** `cache:{provider}:{member_hash}`  
**Value:** JSON response from provider  
**TTL:** Configurable expiration time  

---

## 5 — API Endpoints

### POST /api/verify
Request: `{ provider, member_id, dob, last_name }`  
Response: `{ status, verified_at, source, provider_response }`  

### POST /api/policy-info
Request: `{ member_id, dob, last_name }`  
Response: `{ policy_number, coverage_status, expiry_date, source }`  

### GET /api/verify/{request_id}
Fetch stored verification details.  

---

## 6 — Chatbot AI Assistant

### Intents
- **greeting** → “hello”, “hi”  
- **get_policy_number** → “what’s my policy number?”  
- **check_coverage** → “am I covered?”, “is my insurance valid?”  
- **check_expiry** → “when does my policy expire?”  
- **fallback** → anything else  

### Entities
- `policy_number`  
- `member_id`  
- `dob`  

### Conversation Flow
1. User asks: *“Is my insurance valid?”*  
2. Bot → asks for policy number/member ID.  
3. User provides ID.  
4. Bot calls `/api/policy-info`.  
5. Response: *“Yes, your coverage is active until Dec 12, 2025.”*  

---

## 7 — Security
- Authenticated access (JWT).  
- Secrets in environment variables.  
- Encrypt PII at rest (Postgres) and in transit (TLS).  
- Mask sensitive info in logs.  
- Audit every chatbot query.  

---

## 8 — Observability
- Metrics: request counts, chatbot queries, cache hit/miss, response time.  
- Dashboards: Prometheus + Grafana.  
- Error tracking: Sentry.  

---

## 9 — Testing Strategy
- **Backend:** unit tests for API + cache.  
- **Chatbot:** intent classification accuracy tests.  
- **Integration:** mock provider APIs.  
- **E2E:** React chatbot → middleware → backend → provider.  

---

## 10 — Deployment
- **Backend:** Docker + FastAPI.  
- **Chatbot Middleware:** Rasa server OR LangChain container.  
- **Frontend:** React app with chatbot widget.  
- **Infra:** Kubernetes deployment + Helm charts.  
- **In-Memory DB:** Redis cluster with persistence (RDB + AOF backup).  

---

## 11 — Rollout Plan
- **Phase 1:** Core backend + verification API.  
- **Phase 2:** Cache + DB persistence.  
- **Phase 3:** Add chatbot middleware.  
- **Phase 4:** Integrate chatbot in React frontend.  
- **Phase 5:** Security + observability.  
- **Phase 6:** UAT + production release.  

---

## 12 — Example Chatbot Test Cases
- **User:** “When does my policy expire?” → Bot fetches expiry date.  
- **User:** “Am I covered?” → Bot returns coverage status.  
- **User:** “What’s my policy number?” → Bot retrieves stored number.  
- **User:** “Check policy ABC12345” → Bot fetches directly.  
- **Force refresh:** bypass cache, hit provider API.  

---

## 13 — Environment Variables
```
REDIS_URL=redis://localhost:6379/0
REDIS_PASSWORD=...
REDIS_DB_INDEX=0
REDIS_PERSISTENCE_ENABLED=true
CACHE_KEY_SECRET=...
DEFAULT_CACHE_TTL=3600
PROVIDER_A_API_KEY=...
SENTRY_DSN=...
JWT_SECRET=...
CHATBOT_PROVIDER=RASA|LANGCHAIN
OPENAI_API_KEY=...
```

---

## 14 — Timeline
- Week 1: Backend core (verify API).  
- Week 2: DB + caching.  
- Week 3: Policy info endpoint.  
- Week 4: Chatbot middleware setup.  
- Week 5: React chatbot integration.  
- Week 6: Security, logging, metrics.  
- Week 7: E2E tests + rollout.  

---

## 15 — Acceptance Criteria
- User can query via form OR chatbot.  
- Policy number, coverage, expiry retrieved correctly.  
- Cache hit ratio measurable.  
- Chatbot handles fallback gracefully.  
- All queries securely logged.  
- Production metrics available.  
